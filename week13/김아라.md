## chapter 3. 프라미스

비동기를 다룰 때 콜백을 사용하면 '제어의 역전'으로 순차성과 믿음성이 결여되는 결함이 있다.  
'제어의 역전을 되역전'시키는 **프라미스(Promise)** 로 이 문제를 해결할 수 있다.

### 3.1 프라미스란
개념 설명을 위해 프라미스란 무엇인지 두 가지 비유를 든다.

### 3.1.1 미랫값

패스트푸드 점에서 치즈 버거 세트 구매해서 받기까지의 시나리오

- 세트 메뉴 주문 : 거래(transaction) 시작
- 주문 번호가 적힌 영수증 : 언젠가는 치즈 버거 세트(**미랫값**)를 주겠노라는 **약속(프라미스)**
- 기다림 : 다른 일 처리 가능
- 점원이 내 주문 번호 외침 : 치즈 버거 세트(**미랫값**) 준비 완료 또는 완료 불가 알림
- (세트 준비가 완료된 경우) 영수증을 돌려주고 치즈 버거 세트를 수령 : 나의 '**미랫값**'이 준비되어 갖고 있던 '**값-프라미스**'를 값 자체와 교환
- (재료가 다 떨어진 경우) 뭐로 점심을 때워야 하나 고민 : '**미랫값**'이 실패 

#### 지금값과 나중값

```javascript
var x, y = 2;

console.log( x + y ); // NaN  <-- 'x'는 아직 세팅 전이다
```

x, y 모두 세팅된 후에 `x + y`를 연산하고 싶다면, 둘 중 하나라도 준비가 덜 됐으면 준비가 될 때 까지 기다려야 한다.

callback에서 해결 방법을 찾으면 다음과 같다.

```javascript
function add(getX,getY,cb) {
	var x, y;
	getX( function(xVal){
		x = xVal;
		// 둘 다 준비됐나?
		if (y != undefined) {
			cb( x + y );	// 더해서 보내
		}
	} );
	getY( function(yVal){
		y = yVal;
		// 둘 다 준비됐나?
		if (x != undefined) {
			cb( x + y );		// 더해서 보내
		}
	} );
}

// `fetchX()` 와 `fetchY()` 는 동기/비동기 함수
// functions
add( fetchX, fetchY, function(sum){
	console.log( sum ); // 너무 쉽지?
} );
```
- '지금'과 '나중'을 둘 다 '나중'으로 만듦
- 시간에 대해 한결같은 결과가 나옴

단점
- 어떤 값을 언제 손에 넣게 될지 몰라서 미리 걱정해야 함
- x, y 뿐만 아니라 더 많은 값(x, y, a, b, c)에 대해 처리해야 한다면 코드가 더 복잡해짐

#### 프라미스 값

프라미스 함수로 간단히 나타낸다면 다음과 같다.
```javascript
function add(xPromise,yPromise) {
	return Promise.all( [xPromise, yPromise] ) // --- (1)
	.then( function(values){ // --- (2)
		return values[0] + values[1];
	} );
}

add( fetchX(), fetchY() ) // --- (3)
.then( function(sum){ // --- (4)
	console.log( sum );
} );
```
- (1) - `Promise.all([...])`는 프라미스 배열을 인자로 받아 프라미스들이 모두 귀결될 떄까지 기다렸다가 새 프라미스를 만들어 반환함
- (2) - 프라미스가 귀결되면 'X'와 'Y' 값을 받아 더함
- (3) - `fetchX()`와 `fetchY()`는 각각 값을 가진 프라미스를 반환함. 지금 또는 나중에 준비됨
- (4) - 두 숫자의 합이 담긴 프라미스를 받음. 반환된 프라미스가 귀결될 때까지 대기하기 위해 `then()`을 연쇄 호출

예제에서 볼 수 있는 프라미스의 두 계층
1. add() 내부에서 `Promise.all`으로 `fetchX()`와 `fetchY()`의 반환값(프라미스)을 실행하고, 각각의 값 준비 시점에 상관없이 `then()`에서 같은 결과를 내도록 함
2. add()에서 반환된 `값-프로미스`로 `then()`을 호출하여 값을 얻어내고 콘솔에 출력

프라미스 then() 함수는 **이룸 함수**를 첫 번째 인자로, **버림 함수**를 두 번째 인자로 각각 넘겨받는다.
```javascript
add( fetchX(), fetchY() )
.then(
	// 이룸 함수
	function(sum) {
		console.log( sum );
	},
	// 버림 함수
	function(err) {
		console.error( err ); // bummer!
	}
);
```
- X 또는 Y 조회 시 문제가 있거나 덧셈 연산이 실패하면, 에러 처리 콜백(두번째 콜백)이 실행됨
- 버림 함수 인자로 버림값이 들어옴

프라미스 핵심 개념
- 시간 독립적
  - 시간 의존적인 상태를 외부로부터 캡슐화하여 타이밍 또는 내부 결괏값에 상관 없이 결과값이 예측 가능함
- 불변성(Immutability)
  - 귀결된 후에는 상태가 그대로 유지됨
  - 귀결되고 나면 사고로 또는 악의적으로 변경되는 일은 없으므로 안심하고 다른 파트에 전달할 수 있음
  - 어느 파트가 바라보고 있는 프라미스 귀결에 다른 파트가 영향을 줄 수 없음

#### 3.1.2 완료 이벤트
프라미스의 귀결은 비동기 작업의 여러 단계를 '흐름 제어'라기 위한 체계라 볼 수 있다.

foo() 함수 실행 후 다음 단계를 진행하려면 foo()의 완료 이벤트를 받아야 한다.  
foo()의 **완료 이벤트**를 받았다면 다음 단계를 진행 한다.

```javascript
function foo(x) {
	// 시간이 제법 걸리는 일을 실행한다.
  // 이벤트 구독기를 생성하여 반환한다.
	return listener;
}

var evt = foo( 42 );

evt.on( "completion", function(){
	// 이제 다음 단계로 갈 수 있다.
} );

evt.on( "failure", function(err){
	// 어랏, `foo(..)`에서 뭔가 잘못됐다.
} );
```

- foo()는 호출부에서 이벤트를 받아 어떻게 처리할지 알 필요 없음
- 이벤트 리스너는 리스닝하는 이벤트가 오면 코드를 실행하기만 하면 됨

콜백은 제어의 역전이라고 했었다.  
완료 이벤트를 사용하여 콜백 패턴을 뒤집는 것은  **제어의 되역전**이고, 제어권을 다시 호출부에 갖는다.

이렇게 되면 여러 파트로 나뉘어진 코드가 이벤트를 리스닝하면서, foo() 완료시 독립적으로 알림을 받아 이후 단계를 진행하게 된다.

```javascript
var evt = foo( 42 );

// `bar(..)`는 `foo(..)`의 완료 이벤트를 리스닝한다.
bar( evt );

// `baz(..)`도 `foo(..)`의 완료 이벤트를 리스닝한다.
baz( evt );
```

evt 객체가 독립적인 함수들 사이에서 중재자 역할을 수행한다.

#### 프라미스 '이벤트'
evt는 프라미스와 유사하다.  
foo()는 프라미스 인스턴스를 생성하여 반환하고 이 프라미스를 bar()와 baz()에 전달할 것이다.

```javascript
function foo(x) {
	// 시간이 제법 걸리는 일을 시작한다.
	return new Promise( function(resolve,reject){
    // 결과적으로 `resolve()`, `reject()` 중 한쪽을 호출하게 되고
    // 이들은 프라미스의 귀결 콜백 함수 역할을 한다.
	} );
}

var p = foo( 42 );

bar( p );

baz( p );
```
```javascript
function bar(fooPromise) {
	// `foo(..)`의 완료 여부를 리스닝한다.
	fooPromise.then(
		function(){
			// `foo(..)`는 이제 `bar()` 작업을 한다.
		},
		function(){
			// 어랏, `foo(..)`에서 뭔가 잘못됐다.
		}
	);
}

// `baz(..)`도 마찬가지
```
- 프라미스를 미랫 값으로 다루었을 때처럼 프라미스 귀결 시 어떤 메시지를 보내야 하는건 아니다.
- 단지 흐름 제어 신호로 쓰일 수도 있다.

```javascript
function bar() {
	// `foo(..)`는 확실히 끝났으므로 `bar()` 작업을 한다.
}

function oopsBar() {
	// 어랏, `foo(..)`에서 뭔가 잘못되어 `bar()`는 실행되지 않는다.
}

// `baz()`와 `oopsBaz()`도 마찬가지

var p = foo( 42 );

p.then( bar, oopsBar );

p.then( baz, oopsBaz );
```
- 프라미스 p를 bar(), baz()에 태워보내는 대신 bar(), baz() 두 함수의 실행 이후를 제어하기 위해 프라미스를 이용한다.
- 앞 예제와 가장 두드러진 차이점은 에러 처리 방식이다.  
(에러 발생 시, 'bar()와 baz()가 실행 된 후에 처리되는 것'과 '에러 발생으로 인해 bar()와 baz()는 실행되지 않도록 하는 것'에 차이가 있음)

두 예제 모두 같은 프라미스 p에 대해 then을 두 번 호출하는 부분에서, 프라미스는 일단 귀결되면 똑같은 결과(이룸/버림)을 영원히 유지하므로 이후에 필요하다면 몇번이고 계속 꺼내 쓸 수 있음을 알 수 있다.

### 3.2 데너블 덕 타이핑(Thenable Duck Typing)
