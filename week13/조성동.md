---
tags: You Dont Know JS
study: ch3 프라미스 (~3.4)
---

# Week 13

## Ch3. 프라미스

- 프라미스로 콜백의 순차성과 믿음성에 대한 문제를 해결할 수 있다.

### 3.1 프라미스란

#### 3.1.1 미랫값

- 치즈버거 예제, 미랫값은 성공 아니면 실패이다.

##### 지금값과 나중값

```javascript
var x, y = 2

console.log(x + y) // NaN. < -- 'x'는 아직 세팅 전이다
```

- x, y 값이 이미 세팅된 값으로 본다. 하지만 어떤 문은 지금 실행되고 다른 문은 나중에 실행되면 프로그램이 혼돈의 늪에 빠지게 된다.
- x와 y를 세팅하고 x + y를 수행하는 걸 기대한다.

##### 프라미스 값

```javascript
function add(xPromise, yPromise) {
  // all은 프라미스 배열을 인자로 받아 모두 resolve될 때까지 기다렸다가 새 프라미스를 만들어 반환한다.
  // 프라미스가 resolve되면 x와 y값을 받아 더한다.
  return Promise.all([xPromise, yPromise]).then(function (values) {
    // values는 앞의 프라미스가 건네준 메시지 배열이다.
    return values[0] + values[1]
  })
}

add(fetchX(), fetchY()).then(function (sum) {
  console.log(sum)
})
```

```javascript
// 두 숫자의 합이 담긴 프라미스를 받는다.
add(fetchX(), fetchY()).then(
  // fulfill
  function (sum) {
    console.log(sum)
  },
  function (err) {
    console.error(err)
  }
)
```

- 프라미스는 시간 의존적인 상태를 외부로부터 캡슐화 하기 때문에 프라미스 자체는 시간 독립적이고 그래서 타이밍 또는 내부 결과 값에 상관없이 예측가능한 방향으로 구성할 수 있다. (불변성)

#### 3.1.2 완료 이벤트

- 프라미스 각각은 미랫값으로써 작동하지만 프라미스의 귀결은 비동기 작업의 여러 단계를 '흐름 제어' 하기 위한 체계라 볼 수 있다.

```javascript
foo(x) {
  // 뭔가 시간이 제법 걸리는 일을 시작한다.
}

foo(42);

on(foo, '완료') {
  // 이제 다음 단계로 갈 수 있다!
}

on(foo, '에러') {
  // 어랏, 'foo()'에서 뭔가 잘못됐다.
}
```
