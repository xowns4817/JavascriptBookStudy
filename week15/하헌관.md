## 3.7 프라미스 API 복습
### 3.7.1 new Promise() 생성자
Promise() 생성자는 항상 new와 함께 사용하며 동기적으로/즉시 호출할 콜백 함수를 전달해야 한다. 이 함수에는 다시 프라미스를 귀결 처리할 콜백 2개를 넘기는데 resolve()와 reject()라고 명명하는 것이 보통이다.

```
var p = new Promise( function(resolve,reject){
	// `resolve(..)` to resolve/fulfill the promise
	// `reject(..)` to reject the promise
} );
```

reject()는 그냥 프라미스를 버리지만 resolve()는 넘어온 값을 버고 이룸/버림 중 한 가지로 처리한다.

즉시값, 프라미스 아닌/데너블 아닌 값이 resolve()에 흘러오면 이 프라미스는 해당 값으로 이루어지고 resolve()에 진짜 프라미스/데너블 값이 전달되면 재귀적으로 풀어보고 결국 그 최종값이 프라미스의 마지막 귀결/상태가 된다.

### 3.7.2 Promise.resolve()와 Promise.reject()
두 프라미스는 본질적으로 동등하다.
```
var p1 = new Promise( function(resolve,reject){
	reject( "Oops" );
} );

var p2 = Promise.reject( "Oops" );
```
Promise.resolve()는 데너블 값을 재귀적으로 풀어보고 그 최종 귀결 값(이룸/버림)이 결국 반환된 프라미스에 해당된다.

```
var fulfilledTh = {
	then: function(cb) { cb( 42 ); }
};
var rejectedTh = {
	then: function(cb,errCb) {
		errCb( "Oops" );
	}
};

var p1 = Promise.resolve( fulfilledTh );
var p2 = Promise.resolve( rejectedTh );

// `p1` will be a fulfilled promise
// `p2` will be a rejected promise
```
Promise.resolve()에 진짜 프라미스를 넣으면 아무 일도 하지 않는다는 점을 기억하길 바란다.

### 3.7.3 then()과 catch()
각 프라미스 인스턴스엔 then(), catch() 메서드가 들어있고 프라미스에 이룸/버림 처리기를 등록할 수 있다. 프라미스가 귀결되면 두 처리기 중 딱 하나만 언제나 비동기적으로 호출된다.

then()은 하나 또는 두 개의 인자를 받는데 첫 번째는 이룸 콜백, 두 번째는 버림 콜백이다. 어느 한쪽을 누락하거나 함수가 아닌 값으로 지정하면 각각 기본 콜백으로 대체된다.

catch()는 버림 콜백 하나만 받고 이룸 콜백은 기본 이룸 콜백으로 대체한다.
```
p.then( fulfilled );

p.then( fulfilled, rejected );

p.catch( rejected ); // or `p.then( null, rejected )`
```
then(), catch()도 새 프라미스를 만들어 반환하므로 프라미스 여놰 형태로 흐름 제어를 표현할 수 있다. 이룸/버림 콜백에서 예외가 발생하면 반환된 프라미스는 버린다.

### 3.7.4 Promise.all([])과 Promise.race([])
Promise.all([])과 Promise.race([])는 프라미스를 생성하여 반환하는 ES6 프라미스 API의 정적 헬퍼 유틸리티다.

Promise.all([])은 주어진 모든 프라미스들이 이루어져야 메인 프라미스도 이루어지고 단 하나라도 버려지게 되면 메인 반환 프라미스 역시 곧바로 폐기된다.
이루어지면 각 프라미스의 이룸값이 담긴 배열을, 버려지면 처음 버려진 프라미스의 버림 사유를 돌려받는다.

Promise.race([])는 오직 최초로 귀결된 프라미스만 승자가 되고 그 귀결 값을 반환할 프라미스의 귀결 값으로 삼는다.
```
var p1 = Promise.resolve( 42 );
var p2 = Promise.resolve( "Hello World" );
var p3 = Promise.reject( "Oops" );

Promise.race( [p1,p2,p3] )
.then( function(msg){
	console.log( msg );		// 42
} );

Promise.all( [p1,p2,p3] )
.catch( function(err){
	console.error( err );	// "Oops"
} );

Promise.all( [p1,p2] )
.then( function(msgs){
	console.log( msgs );	// [42,"Hello World"]
} );
```

## 3.8 프라미스 한계
### 3.8.1 시퀀스 에러 처리
프라미스의 설계 상 한계 탓에 프라미스 연쇄에서 에러가 나면 그냥 조용히 묻어버리기 쉽다.

에러 처리기가 없는 프라미스 연쇄에서 에러가 나면 나중에 어딘가에서 감지될 때까지 연쇄를 따라 죽 하위로 전파한다.

```
// `foo(..)`, `STEP2(..)` and `STEP3(..)` are
// all promise-aware utilities

var p = foo( 42 )
.then( STEP2 )
.then( STEP3 );
```
p가 가리키는 대상은 이 연쇄의 첫 번째 프라미스가 아니라 then(STEP3) 호출 후 반환된 마지막 프라미스다.

또 프라미스 연쇄는 각 단계에서 자신의 에러를 감지하여 처리할 방법 자체가 없으니 p에 에러 처리기를 달아놓으면 연쇄 어디에서 에러가 나도 이를 받아 처리할 수 있다.

```
p.catch( handleErrors );
```
하지만 연쇄 어느 단계에서 나름대로 에러 처리를 하면 handleErrors()는 에러를 감지할 방법이 없다

이것은 try ... catch에도 기본적으로 존재하는 한계로, 예외가 잡혀도 그냥 묻혀버릴 가능성은 얼마든지 있다.

### 3.8.2 단일값
프라미스는 정의 상 하나의 이룸값, 아니면 하나의 버림 사유를 가진다.

## 3.9 정리
- 콜백식 코드에서 '제어의 역전' 문제를 해결가능
- 콜백을 완전히 없애는 건 아니며, 기존 콜백 코드를 믿을 만한 중계자 역할을 수행하는 유틸리티를 통해 잘 조정하여 서로 조화롭게 작동할 수 있도록 유도한 것
- 제너레이터에서 한층 더 개선된 솔루션을 소개 할 예정