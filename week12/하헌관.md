# Chapter 2. 콜백
콜백은 자바스크립트에서 비동기성을 표현하고 관리하는 가장 일반적인 기법이자, 사실상 자바스크립트 언어에서 가장 기본적인 비동기 패턴이다.

## 2.1 연속성
앞서 봤던 비동기 콜백 예제를 보자.
```
// A
ajax( "..", function(..){
	// C
} );
// B
```
A와 B는 프로그램 전반부('지금'), C는 프로그램 후반부('나중')에 각각 해당한다.

전반부 코드가 실행되면 비결정적 시간동안 중지되고 언젠가 AJAX 호출이 끝날 때 중지되기 이전 위치로 다시 돌아와서 나머지 후반부 프로그램이 이어진다.  
다시 말해, 콜백 함수는 프로그램의 연속성을 감싼/캡슐화한 장치다.

코드를 더 간단히 하면
```
// A
setTimeout( function(){
	// C
}, 1000 );
// B
```
"A를 실행한 다음 1,000밀리 초 타임아웃을 설정하고 B를 실행하고 타임아웃 시 C를 실행한다." => 잘 설명했다고 하기엔 부족하다.

Stack, webapis(background), Queue가 맞물려서 동작되는 전체 시퀀스를 완벽히 이해해야 한다.


## 2.2 두뇌는 순차적이다
사람은 싱글태스커에 더 가깝다. 인간의 두뇌가 마치 단일 스레드 방식의 이벤트 루프 큐처럼 작동한다.

### 2.2.1 실행 vs 계획
콜백은 비동기 흐름을 비선형적, 비순차적인 방향으로 나타내므로 제대로 이해하기가 어렵다.


### 2.2.2 중첩/연쇄된 콜백
```
listen( "click", function handler(evt){
	setTimeout( function request(){
		ajax( "http://some.url.1", function response(text){
			if (text == "hello") {
				handler();
			}
			else if (text == "world") {
				request();
			}
		} );
	}, 500) ;
} );
```
비동기 단계를 3개의 함수가 서로 중첩된 형태로 표현했다.  
이른바 콜백 지옥 또는 운명의 피라미드라고도 불리는 코드이다.

클릭 이벤트 대기 -> 타이머 동작까지 대기 -> AJAX 응답을 받을 때까지 대기 순으로 진행하고 이후 처음부터 되풀이 된다.

언뜻 보면 이 코드 자체의 비동기성은 자연스럽게 잘 조화되는 것처럼 보인다.

'지금'
```
listen( "..", function handler(..){
	// ..
} );
```

'나중'
```
setTimeout( function request(..){
	// ..
}, 500) ;
```

더 '나중'
```
ajax( "..", function response(..){
	// ..
} );
```

제일 '나중'
```
if ( .. ) {
	// ..
}
else ..
```
그러나 이런 식의 선형적인 코드 추론에는 몇 가지 문제점이 있다.

단순히 순차 실행될 경우는 많은 경우의 수 중 하나에 불과하다.  
실제 비동기 자바스크립트 프로그램에는 갖가지 잡음이 섞인다.

다른 예제를 살펴보자.
```
doA( function(){
	doB();

	doC( function(){
		doD();
	} )

	doE();
} );

doF();
```
이 코드의 실행 순서는 다음과 같다.
- doA()
- doF()
- doB()
- doC()
- doE()
- doD()

실행 순서와 알파벳 순서를 일치하도록 바꿔보면
```
doA( function(){
	doC();

	doD( function(){
		doF();
	} )

	doE();
} );

doB();
```
만약 doA()나 doD()가 비동기 코드가 아니라면?
A->C->D->F->E->B 순으로 실행된다.

중첩이 원인인가? 비동기 흐름을 따라가기 어렵기 만드는 주범이 중첩인가?

중첩없이 이벤트/타임아웃/AJAX 예제를 다시 써보면,
```
listen( "click", handler );

function handler() {
	setTimeout( request, 500 );
}

function request(){
	ajax( "http://some.url.1", response );
}

function response(text){
	if (text == "hello") {
		handler();
	}
	else if (text == "world") {
		request();
	}
}
```
이전 코드보다 알아보기는 편하지만 여전히 콜백 지옥에 취약한 건 마찬가지다.

선형적으로 이 코드를 추론하자면 한 함수에서 다음 함수로, 또 그 다음 함수로, 시퀀스 흐름을 따라가기 위해 코드 베이스 전체를 널뛰기해야 한다. 이 예제는 단순한 코드고 실무에서 추론의 어려움은 차원이 다르다.

눈여겨볼 부분이 있다. 2, 3, 4 단계를 연결하여 연속 실행하고 싶을 때 콜백만으로 할 수 있는 일은 1단계 코드에 2단계 코드를, 3단계 코드에 2단계 코드를, 4단계 코드에 3단계 코드를 하드 코딩하여 넣는 정도다. 

하지만 하드 코딩은 기본적으로 부실한 코드를 양산하기에 단계가 나아가는 도중 엉뚱한 일들이 발생하여 오류가 나는 것까지 대비할 수는 없다. 가령 2단계에서 실패하면 2단계 재시도는 물론이고 3단계는 아예 시작도 못하거나 별도의 에러 처리 루틴으로 빠져버린다.

수작업으로 하드 코딩한 콜백은 대부분 바람직하지 않다.
만일의 사탵와 가능한 경우의 수를 죄다 나열하다간 코드가 너무 복잡해져 버려 관리 및 수정이 난처해진다.

바로 이것이 콜백 지옥이다. 중첩/들여쓰기 같은 건 주의를 분산시키는 부수적인 요소일 뿐, 복수의 연속된 콜백이 서로 연쇄된 상태로 동시 발생하거나, 관문이나 걸쇠 등의 병렬 콜백으로 분기하는 단계 등 머리아픈 일이 훨씬 많다.

## 2.3 믿음성 문제
순차적인 두뇌 계획과 콜백식 비동기 자바스크립트 코드 사이의 부조화는 콜백 문제점의 일부에 불과하다. 

콜백 함수의 개념을 프로그램의 연속이란 관점에서 보자.
```
// A
ajax( "..", function(..){
	// C
} );
// B
```
A와 B는 자바스크립트 메인 프로그램의 제어를 직접 받으며 '지금' 실행되지만 C는 다른 프로그램의 제어하에 '나중'에 실행된다. 제어권을 주고받는 행위 때문에 프로그램이 항상 탈이 나는 건 아니다.

사실 제어권 교환이야말로 콜백 중심적 설계 방식의 가장 큰 문제점이다.

콜백을 넘겨주는 ajax()는 개발자가 작성하는 또는 개발자가 직접 제어할 수 있는 함수가 아니라 서트 파티가 제공한 유틸리티인 경우가 대부분이다.

내가 작성한 프로그램인데도 실행 흐름은 서드 파티에 의존해야 하는 상황을 제어의 역전이라고 한다.

### 2.3.1 다섯 마리 콜백 이야기
여러분이 TV를 판매하는 전자상거래 결제 시스템을 구축하는 담당 개발자라고 하자. TV를 구매하려는 고객이 '확인' 버튼을 클릭하면 서드 파티 함수를 호출하여 구매 정보를 추적할 수 있게 되어 있다.

이 추적 유틸리티는 아마 성능 문제 때문에 비동기 식으로 코딩된 것 같은데 호출 시 콜백 함수를 같이 넘겨야 한다. 콜백 함수가 시작되면 고객의 신용 카드를 결제하고 감사 페이지로 이동하는 코드가 잇따라 실행된다.

```
analytics.trackPurchase( purchaseData, function(){
	chargeCreditCard();
	displayThankyouPage();
} );
```

반년 후 고객이 TV를 구매했는데 5번이나 연속 결제되었다.

로그 파일을 보니 이 추적 유틸리티가 여러분이 작성한 콜백 함수를 한 번만 호출해야 하는데 다섯 차례나 호출되었다.

문제는 솔루션 업체가 납품한 코드 중 특정 조건에서 초당 한 번씩 주어진 콜백 함수를 호출하는데, 최대 5초 동안 재시도하다가 타임아웃 에러를 내도록 만들어진 테스트 단계의 코드가 포함된 것이 문제를 일으켰다.

우선 임시로 다음과 같이 수정한다.
```
var tracked = false;

analytics.trackPurchase( purchaseData, function(){
	if (!tracked) {
		tracked = true;
		chargeCreditCard();
		displayThankyouPage();
	}
} );
```
만약 업체 측 함수가 콜백을 한 번도 호출하지 않으면..?  
수많은 경우의 수를 열거하면..
- (추적이 끝나기도 전에)콜백을 너무 일찍 부른다
- (아예 호출하지 않거나)콜백을 너무 늦게 부른다
- 콜백을 너무 적게 또는 너무 많이 부른다
- 필요한 환경/인자를 정상적으로 콜백에 전달하지 못한다
- 일어나지 모를 에러/예외를 무시한다.

### 2.3.2 남의 코드뿐만 아니라
여러분은 이론적으로 제어하는 유틸리티를 정말 신뢰할 수 있는가?

개발자는 대부분 예기치 못한 상황을 방지하고 줄이고자 내부 함수 작성 시 입력 인자 체크 등 나름의 방어 로직을 짜 넣는다.

입력 인자를 굳게 믿는다면,
```
function addNumbers(x,y) {
	// + 연산자는 인자를 문자열로 강제변환한 뒤
	// 덧붙이는 형태로 오버로딩 할 수 있기 때문에
	// 전달되는 값에 따라 항상 안전한 것은 아니다.
	return x + y;
}

addNumbers( 21, 21 );	// 42
addNumbers( 21, "21" );	// "2121"
```
인자를 못 믿어 방어 코드를 넣으면
```
function addNumbers(x,y) {
	// 인자가 숫자인지 확인
	if (typeof x != "number" || typeof y != "number") {
		throw Error( "Bad parameters" );
	}

	// 인자가 숫자라면	
	return x + y;
}

addNumbers( 21, 21 );	// 42
addNumbers( 21, "21" );	// Error: "Bad parameters"
```
아니면 안전하면서도 좀 더 친절하게,
```
function addNumbers(x,y) {
	// 숫자로 형변환
	x = Number( x );
	y = Number( y );

	// +는 안전한 덧셈 연산을 할 것이다.
	return x + y;
}

addNumbers( 21, 21 );	// 42
addNumbers( 21, "21" );	// 42
```
어떻게 구현되든 이런 식의 합수 입력값에 대한 체크/정규화 로직은 지극히 당연하며 우리가 이론적으로 완전히 믿고 쓰는 코드도 예외는 아니다.

그렇다면 완전 외부 코드뿐 아니라 개발자 본인이 좌지우지할 수 있는 코드에 포함된 비동기 함수 호출에 대해서도 같은 원리를 적용해야 할까? 물론, 그래야 한다

하지만 콜백 자체는 별로 도움이 안 된다. 결국, 매번 비동기적으로 부를 때마다 콜백 함수에 반복적인 관영 코드/오버헤드를 넣는 식으로 손수 필요한 장치를 만들어야 한다.

콜백의 가장 골치 아픈 부분이 제어의 역전 문제다.

## 2.4 콜백을 구하라.
지금까지 살펴본 믿음성 문제를 일부라도 해결하기 위해 기존 디자인을 변형한 콜백 체계가 있다.

예를 들어, 더욱 우아하게 에러를 처리하려고 분할 콜백 기능을 제공하는 API가 있다.
```
function success(data) {
	console.log( data );
}

function failure(err) {
	console.error( err );
}

ajax( "http://some.url.1", success, failure );
```
이러한 API 설계에서 에러 처리기 failure()는 필수가 아니며, 작성하지 않으면 에러는 조용히 무시된다.

에러 우선 스타일이라는 콜백 패턴(노드스타일) 또한 많이 쓴다. 단일 콜백 함수는 에러 객체(오류발생 시)를 첫 번째 인자로 받는다. 성공 시 이 인자는 빈/falsy 객체로 채워지지만, 실패시 truthy 또는 에러 객체로 세팅된다.
```
function response(err,data) {
	// error?
	if (err) {
		console.error( err );
	}
	// otherwise, assume success
	else {
		console.log( data );
	}
}

ajax( "http://some.url.1", response );
```
두 경우 모두 몇 가지 사실을 알 수 있다.

우선, 일견 믿음성 문제가 대체로 해결된 것처럼 보이지만 실상 그렇지 않다. 원하지 않는 반복적인 호출을 방지하거나 걸러내는 콜백 기능이 전혀 없다. 더구나 이제는 성공/에러 신호를 동시에 받거나 아예 못 받을 수도 있으므로 상황별로 코딩해야 하는 부담까지 가중됐다.

또 한 가지 놓쳐서는 안 될 점이 표준적인 패턴의 모습을 띠고 있음에도 재사용 불가능한, 장황한 관용 코드라서 실제로 애플리케이션을 개발할 때 매 콜백마다 타이핑해야 한다면 금세 지쳐버릴 것이다.

콜백을 한 번도 호출하지 않으면? 이런 경우가 중요하다면 이벤트를 취소하는 타임아웃을 걸어놓아야 한다.
```
function timeoutify(fn,delay) {
	var intv = setTimeout( function(){
			intv = null;
			fn( new Error( "Timeout!" ) );
		}, delay )
	;

	return function() {
		// timeout hasn't happened yet?
		if (intv) {
			clearTimeout( intv );
			fn.apply( this, [ null ].concat( [].slice.call( arguments ) ) );
		}
	};
}
```
쓰는 방법은,
```
// using "error-first style" callback design
function foo(err,data) {
	if (err) {
		console.error( err );
	}
	else {
		console.log( data );
	}
}

ajax( "http://some.url.1", timeoutify( foo, 500 ) );
```
너무 일찍 콜백을 호출해도 문제다. 애플리케이션 관점에서 보면 실제로 어떤 중요한 작업을 마치기 전에 콜백을 부른 것이다. 하지만 더 넓은 시야에서 보면 유틸리티에 전달한 콜백을 지금 또는 나중에 시작할 주체인 유틸리티에 문제가 있다.

다음 예제를 보자
```
function result(data) {
	console.log( a );
}

var a = 0;

ajax( "..미리 캐시된 URL..", result );
a++;
```
콘솔창 결과는 0일까 1일까? 조건에 따라 다르다.
불가측성이 얼마나 쉽게 자바스크립트를 위험에 빠뜨릴 수 있는지 잘 보여주는 예다.

주어진 API가 항상 비동기로 작동할지 확신이 없다면? 다음 asyncify() 같은 유틸리티를 만들어 쓰면 된다.

```
function asyncify(fn) {
	var orig_fn = fn,
		intv = setTimeout( function(){
			intv = null;
			if (fn) fn();
		}, 0 )
	;

	fn = null;

	return function() {
		// 비동기 차례를 지나갔다는 사실을 나타내기 위해
		// 'intv' 타이머가 기동하기도 전에 너무 빨리 발사
		if (intv) {
			fn = orig_fn.bind.apply(
				orig_fn,
				// 인자로 전달된 값들을 커링하면서
				// 감싸미의 'this'에 'bind()' 호출 인자를 추가한다.
				[this].concat( [].slice.call( arguments ) )
			);
		}
		// 이미 비동기
		else {
			// 원본 함수 호출
			orig_fn.apply( this, arguments );
		}
	};
}
```

사용법:
```
function result(data) {
	console.log( a );
}

var a = 0;

ajax( "..pre-cached-url..", asyncify( result ) );
a++;
```
AJAX 요청을 캐시한 상태에서 즉각 콜백을 호출하여 귀결하든지, 아니면 데이터를 다른 곳에서 가져오는 터라 나중에 비동기적으로 완료되든지, 어쨋거나 결과값은 항상 1이 된다.
result()는 비동기적으로 부를 수 밖에 없고 따라서 a++는 result()보다 먼저 실행된다.



## 2.5 정리하기
- 콜백은 자바스크립트에서 비동기성을 표현하는 기본 단위
- 사람의 두뇌는 순차적, 중단적, 단일-스레드 방식으로 계획하는 데 익숙하지만 콜백은 비동기 흐름을 비선형적, 비순차적인 방향으로 나타내므로 제대로 이해하기가 어려움
- 콜백은 프로그램을 진행하기 위해 제어를 역전, 즉 제어권을 다른 파트에 암시적으로 넘겨줘야 하므로 골치아프며 믿음성 문제에 봉착하게 됨
- 믿음성 문제를 해결하고자 임시 로직을 짜 넣으면 당장은 난관을 모면할 수 있지만 구현하기 쉽지 않고 유지보수가 힘듦
- 프라미스가 이러한 문제점을 해결해줄 것..?

